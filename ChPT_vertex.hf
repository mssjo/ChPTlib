#ifndef `CHPTVERTEXHF'
#define CHPTVERTEXHF

* Procedures related to specifying vertices

#include- ChPT_defs.hf

********************************************************************************

#procedure doderivs()
    argument derivs;
        repeat id sum(p?,q?, ?q) = sum(p+q, ?q);
        id sum(p?) = p;
    endargument;
    repeat id derivs(q?, ?lz, mu?) = i_*q(mu) * derivs(q, ?lz);
    id derivs(q?) = 1;
#endprocedure

#procedure makevertex(ID,ORD,NM,NV,NA,NS,NP)

    #if `ORD'==LO
        #define ORD "2"
    #elseif `ORD'==NLO
        #define ORD "4"
    #elseif `ORD'==NNLO || `ORD'==N2LO
        #define ORD "6"
    #elseif `ORD'==NNNLO || `ORD'==N3LO
        #define ORD "8"
    #endif

    #if `ORDER' < `ORD'
*         Ignore vertices of too high order
        #message[makevertex]~~~ vertex `ID' omitted: requested order `ORD' higher than ORDER=`ORDER'
        local vert`ID' = 0;
        .sort:>>barevertex: `ID'<<;
    #else
        .sort

        #define NX "{`NM'+`NV'}"

        #ifndef `EXTENDFLAV'
            #define EXTENDFLAV "`NEXT'"
        #endif
        #if `EXTENDFLAV'<`NM'
            indices <f{`EXTENDFLAV'+1}=Nf>,...,<f`NM'=Nf>;
            #redefine EXTENDFLAV "`NM'"
        #endif

        indices <i`ID'x1>,...,<i`ID'x`NX'>;
        indices <f`ID'x1>,...,<f`ID'x`NM'>;
        set f`ID'x: <f`ID'x1>,...,<f`ID'x`NM'>;

        indices <mu`ID'x1>,...,<mu`ID'x`ORD'>;
        set mu`ID'x: <mu`ID'x1>,...,<mu`ID'x`ORD'>;

        vectors <p`ID'x1>,...,<p`ID'x`NX'>;
        set p`ID'x: <p`ID'x1>,...,<p`ID'x`NX'>;

        #define ORDER "`ORD'"
        #if {`NV'+`NA'}
            #define HASVECTOR
            cfunctions V,A;
        #endif
        #if {`NS'+`NP'}
            #define HASSCALAR
            cfunctions S,P;
        #endif

        skip;

        #include names.hf

        local vert`ID' =
            #ifdef `SQED'
                #if `NA'||`NS'||`NP'
                    0;
                #else
                    #call SQEDvertex(`ID',`ORD',`NM',`NV')
                #endif
            #else
                #system cd `VERTEXDIR'/.. && `MAKECMD' `VERTEXFILE'
                #message[makevertex]~~~ importing `VERTEXFILE'
                #include- `VERTEXFILE'
                ;
            #endif

        multiply replace_(<lorentz[1],mu`ID'x[1]>,...,<lorentz[`ORD'],mu`ID'x[`ORD']>);
        #if `NM'
            multiply replace_(<f1,f`ID'x1>,...,<f`NM',f`ID'x`NM'>);
        #endif

        bracket Tr;
        print +s;
        .sort:>>makevertex: `ID'<<;
    #endif

#endprocedure

#procedure SQEDvertex(ID,ORD,NM,NV)

    #if `ORD'==LO
        #define ORD "2"
    #elseif `ORD'==NLO
        #define ORD "4"
    #elseif `ORD'==NNLO || `ORD'==N2LO
        #define ORD "6"
    #elseif `ORD'==NNNLO || `ORD'==N3LO
        #define ORD "8"
    #endif

    #if (`NM'==2) && (`NV'==2)
        e^2 * A(mu`ID'1)*A(mu`ID'1) * phi(f`ID'1)*phi(f`ID'2) * delEE(`ORD')
    #elseif (`NM'==2) && (`NV'==1)
        -i_*e * (phi(f`ID'1, mu`ID'1)*phi(f`ID'2) - phi(f`ID'1)*phi(f`ID'2, mu`ID'1)) * A(mu`ID'1)  * delE(`ORD')
    #elseif (`NM'==4) && (`NV'==0)
        -i_*lambda/fac_(4) * <phi(f`ID'1)>*...*<phi(f`ID'4)> * delL(`ORD')
    #elseif (`NM'==2) && (`NV'==0)
        i_*(phi(f`ID'1,mu`ID'1)*phi(f`ID'2,mu`ID'1) * delZ(`ORD') - phi(f`ID'1)*phi(f`ID'2) * delM(`ORD'))
    #elseif (`NM'==0) && (`NV'==2)
        -i_*(A(mu`ID'1,mu`ID'2)*A(mu`ID'1,mu`ID'2) - A(mu`ID'1,mu`ID'2)*A(mu`ID'2,mu`ID'1)) * delA(`ORD')
    #else
        0
    #endif

*     One SQED tensor holds the indices of phi, the other those of phi*
*      (doesn't matter which is which).
*     This is to enforce that all contractions are phi-phi* rather than
*      phi-phi or phi*-phi*.
    #if (`NM'>0)
        * SQEDphi(<f`ID'1>,...,<f`ID'{`NM'/2}>)
        * SQEDdag(<f`ID'{`NM'/2+1}>,...,<f`ID'`NM'>)
    #endif

    ;

*     SQED renormalization: each counterterm is viewed as a series del(2)+del(4)+... where each cancels
*     divergences at the loop level of the corresponding ChPT power counting order.
*     id delEE(2) = 1;
*     id delEE(n?) = sum_(m,2,n-2,2, delE(m)*delE(n-m));
    id delZ?{delZ,delM,delA}(2) = 0;
    id delZ?{delE,delEE,delL}(2) = 1;
#endprocedure
