#ifndef `CHPTDEFSHF'
#define CHPTDEFSHF

* Definitions for the ChPT diagram library

* TODO: move the more specific of these to the header file containing the
*  procedures that actually use them.
* This works as long as all of ChPTdiagram.hf is always loaded,
*  and is much more maintainable.

********************************************************************************
* Canonicalizing the power-counting orders, giving default values

#ifndef `ORDER'
* Unspecified order means arbitrarily high order
* and like in the large Nc community, 10 > 3^2 so it's basically infinity
    #define ORDER "10"
#else
*     Convert to numerical orders for easier comparison
    #if `ORDER' == LO
        #redefine ORDER "2"
    #elseif `ORDER' == NLO
        #redefine ORDER "4"
    #elseif `ORDER' == N2LO || `ORDER' == NNLO
        #redefine ORDER "6"
    #elseif `ORDER' == N3LO || `ORDER' == NNNLO
        #redefine ORDER "8"
    #endif
*     Define a uniform N-style order
    #define NORDER "`NORDER`ORDER''"
*     Number of loops allowed at this order
    #define NLOOPS "{`NLOOP(`ORDER')'}"
#endif
#ifndef `MFORDER'
* Unspecified M & F renormalization order means don't bother, i.e., LO
    #define MFORDER "2"
#else
*     Convert to numerical orders for easier comparison
    #if `MFORDER' == LO
        #redefine MFORDER "2"
    #elseif `MFORDER' == NLO
        #redefine MFORDER "4"
    #elseif `MFORDER' == N2LO || `MFORDER' == NNLO
        #redefine MFORDER "6"
    #elseif `MFORDER' == N3LO || `MFORDER' == NNNLO
        #redefine MFORDER "8"
    #endif
#endif

********************************************************************************
* Setup, options and parameters

* Number of external particles
#call require(NEXT)

* Options for masses
#ifdef `FULLMASS'
    #message[ChPTdiagram]~~~ ERROR: full-mass ChPT not supported yet!
    #terminate
#endif
* Three distinct masses: Pion, Kaon, Eta
#ifdef `PKEMASS'
    #ifdef `NF'
        #if `NF'!=3
            #message[defs]~~~ ERROR: PKEMASS fixes NF=3; NF should not be defined separately
            #terminate
        #endif
    #endif
    #define NF "3"
    cfunctions Prop,Prop8,Prop88;
    symbols mhat,ms;
    symbols mp2,mk2,me2, m0p2,m0k2,m0e2;

    #define PFLAV "<f1>,...,<f`NEXT'>"
    #define KFLAV "<F1>,...,<F`NEXT'>"
    #define STRANGE "<S1>,...,<S`NEXT'>"

    symbols `STRANGE';
    set strange: `STRANGE';
    indices `PFLAV', `KFLAV';
    set pflav: `PFLAV';
    set kflav: `KFLAV';
    set pkflav: `PFLAV', `KFLAV';
#else
    #define EQUALMASS
    symbols mp2, m0p2;
#endif

* Options for NG manifold parametrization
#ifndef `PAR'
    #message[defs]~~~ PAR not defined, parametrization defaulting to EXP
    #define PAR "EXP"
#else
    #switch `PAR'
        #case GEN
*             General parametrization as per Bijnens, Husek & Sjo, 2021
            cfunction a;
            #break
        #case SQRT
*             The parametrization U = i_ Phi + sqrt(1 - Phi^2) (omitting normalization)
*             (formerly known as KALPAR since Kalman Szabo suggested using it)
            #ifdef `NF'
                #if `NF'!=2
                    #message[defs]~~~ ERROR: PAR=SQRT fixes NF=2; NF should not be defined separately
                    #terminate
                #endif
            #endif
            #define NF "2"
            #break
        #case EXP
        #case CAY
        #case MIN
        #case BIJ
            #break
        #default
            #message~~~[defs]~~~ ERROR: unknown parametrization "`PAR'"
            #terminate
    #endswitch
#endif

* Scalar QED + phi^4 is a neat reskin of ChPT
#ifdef `SQED'
    #message[ChPTdiagram]~~~ WARNING: scalar QED not fully supported!
    symbols e, lambda;
    function oppositeparity;
    cfunctions delZ,delM,delA,delE,delEE,delL;
#endif

* Number of flavors
symbol Nf;
#ifndef `NF'
    #define NFGENERAL
    #define NF "Nf"
#endif

********************************************************************************
* Internal momenta, Lorentz indices

indices mu,nu,ro,si,ka,la,al,be;
set lorentz: mu,nu,ro,si,ka,la,al,be;

#ifdef `LOOPMOMENTA'
    #do L={`LOOPMOMENTA'}
        vector `L';
        symbol [`L'^2-M^2];
    #enddo
    set loopmomenta:
        #do L={`LOOPMOMENTA'}
            ,`L'
        #enddo
        ;
#else
    #define LOOPMOMENTA "ell"
#endif

#ifndef `PROPMOMENTA'
    #define PROPMOMENTA "`LOOPMOMENTA'"
#endif
#do Q={`PROPMOMENTA'}
    vector `Q';
#enddo

#ifdef `INTMOMENTA'
    #do Q={`INTMOMENTA'}
        vector `Q';
        symbol `Q'sq;
        #do L={`LOOPMOMENTA'}
            vector [`L'+`Q'], [`L'-`Q'], [`Q'-`L'];
            symbol [(`L'+`Q')^2-M^2],[(`L'-`Q')^2-M^2];
            #redefine PROPMOMENTA "[`L'+`Q'],[`L'-`Q'],[`Q'-`L'],`PROPMOMENTA'"
        #enddo
    #enddo
#endif

set loops: `LOOPMOMENTA';

********************************************************************************
* Display preprocessor variables
* Importantly, do this BEFORE all the LECs and stuff are added

#ifndef `QUIET'
    #show
#endif

********************************************************************************
* LECs

#define LECS "B0,F,Fp"
#ifdef `PKEMASS'
    #redefine LECS "`LECS',Fk,Fe"
#endif

#ifdef `NFGENERAL'
    #define NLOLECSBARE "L0,...,L10,H1,H2"
    #define NNLOLECSBARE "K1,...,K115"
    #define N3LOLECSBARE "K8x1,...,K8x1862"
#else
    #if `NF'==3
        #define NLOLECSBARE "L1,...,L10,H1,H2"
        #define NNLOLECSBARE "C1,...,C94"
        #define N3LOLECSBARE "C8x1,...,C8x1254"
    #elseif `NF'==2
        #define NLOLECSBARE "l1,...,l8,h1,h2,h3"
        #define NNLOLECSBARE "c1,...,c57"
        #define N3LOLECSBARE "c8x1,...,c8x475"
    #endif
#endif
#do NXLO={NLO,NNLO,N3LO}
    #define LECVARS "r"
    #ifdef `QRENORM'
        #redefine LECVARS "`LECVARS',q"
    #endif
    #if `NF'==2
        #redefine LECVARS "`LECVARS',b"
    #endif
    #do LEC={``NXLO'LECSBARE'}
        #do LECVAR={`LECVARS'}
*             For some reason, #ifndef fails here
            #if isdefined(`NXLO'LECS`TOUPPER_(`LECVAR')')==0
                #define `NXLO'LECS`TOUPPER_(`LECVAR')' "`LEC'`LECVAR'"
            #else
                #redefine `NXLO'LECS`TOUPPER_(`LECVAR')' "``NXLO'LECS`TOUPPER_(`LECVAR')'',`LEC'`LECVAR'"
            #endif
        #enddo
    #enddo
    #define `NXLO'LECS "``NXLO'LECSBARE'"
    #do LECVAR={`LECVARS'}
        #redefine `NXLO'LECS "``NXLO'LECS',``NXLO'LECS`TOUPPER_(`LECVAR')''"
    #enddo
    #undefine LECVARS
#enddo
* Generic dummy LECs
#define DUMMYLECS "p4LEC,p6LEC,p8LEC"
symbols `DUMMYLECS';
* All LECs up to the relevant order
#if (`ORDER'>=4) || (`MFORDER'>=6)
    #redefine LECS "`LECS',`NLOLECS'"
#endif
#if (`ORDER'>=6) || (`MFORDER'>=6)
    #redefine LECS "`LECS',`NNLOLECS'"
#endif
#if (`ORDER'>=8) || (`MFORDER'>=8)
    #redefine LECS "`LECS',`N3LOLECS'"
#endif
symbols `LECS',`NLOLECS',`NNLOLECS',`N3LOLECS';
set LECs: `LECS';

#procedure pickLEC()
* If PICKLEC is set to a LEC, only terms containing that are kept
* If PICKLECS is set to a list of LECs, only terms containing those are kept
* If PICLECORDER is set to an N*LO order, only terms containing LECs of that order are kept
* Otherwise, this procedure does nothing.

    #define PICKLECVARS "PICKLEC,PICKLECS,PICKLECORDER"
    #call mutex(PICKLECVARS)

    #ifdef `PICKLEC'
        if(count(`PICKLEC',1)==0) discard;
    #endif
    #ifdef `PICKLECS'
        if(count(F,0
        #do `LEC'={`PICKLECS'}
            ,`LEC',1
        #enddo
        )==0) discard;
    #endif
    #ifdef `PICKLECORDER'
        if(match(L?{``PICKLECORDER'LECS'})==0) discard;
    #endif
#endprocedure

********************************************************************************
* Loop integrals

autodeclare cfunction int;

cfunctions tadpole, bubble, triangle;
#define LOOPS "
    A,
    Ab,
    B, B1, B21,B22, B31,B32,
    Bb, B1b, B21b,B22b, B31b,B32b,
    C, Cx11,Cx12,Cx13, Cx21,Cx22,Cx23, Cx31,
    H, HH1, H21,H22,H23,H24,
    V, VV,
    Jbar"
cfunctions `LOOPS';

********************************************************************************
* External particles

#include- defaultext.hf

#ifndef `NOMANDEL'
    symbols s,t,u, [s-t],[t-u],[u-s], [t-s],[u-t],[s-u], [s+t],[t+u],[u+s], [t+s],[u+t],[s+u];
    set mandel: s,t,u, [s-t],[t-u],[u-s], [t-s],[u-t],[s-u], [s+t],[t+u],[u+s], [t+s],[u+t],[s+u];
#endif

indices flav,<f1=`NF'>,...,<f`NEXT'=`NF'>;
set extflav: <f1>,...,<f`NEXT'>;
vectors <p1>,...,<p`NEXT'>;
set extmomenta: <p1>,...,<p`NEXT'>;

indices <i1>,...,<i{`NEXT'*2}>;
vectors <q1>,...,<q{`NEXT'*2}>;

#if `NEXT' <= 4
    set extlorentz: mu,nu,ro,si;
#else
    indices <mu1>,...,<mu`NEXT'>;
    set extlorentz: <mu1>,...,<mu`NEXT'>;
#endif

function ext;
vectors <ext1>,...,<ext`NEXT'>;
set external: <ext1>,...,<ext`NEXT'>;

********************************************************************************
* Miscellaneous

functions Q, Phi;
functions tr,chi;
cfunctions Tr(cyclic), phi, A;
symbols n, <n1>,...,<n`NEXT'>, m, <m1>,...,<m`NEXT'>;
symbols sqrt2,sqrt3,sqrt6;

cfunctions prop, propmatrix, coeff;
functions sum, derivs, dummy;

symbols d, [d], <[d-1]>,...,<[d-4]>;
symbols kappa, eps,etil, log4pi;
symbols L, Lp
    #ifdef `PKEMASS'
        ,Lk,Le
    #endif
    ;

function cross, mirror, cycle, permute, replace;

vectors p,q,k, p0,p1,p2,p3,p4;
symbol qsq, q1sq,q2sq,q3sq, beta;
indices i,j;
symbols sgn,mark;
symbol pi;

#ifdef `SQED'
    ctensors SQED,SQEDphi,SQEDdag;
#endif

********************************************************************************
* Standard bracket statement

#procedure stdbracket
    bracket i_,Tr,`LECS',`LOOPS', F,Fpi, int,prop
        #ifdef `SQED'
            ,e,lambda
        #endif
        ;
#endprocedure

********************************************************************************
* Conversion between different Nf

#procedure invertcayham(ORD,FROM,TO)
    #if (`ORD' == 4)||(`ORD' == NLO)
        #if (`FROM' == 3)&&(`TO' == N)
*             Bijnens, Colangelo & Ecker '99 eq. (3.15)
            id L1 = L0/2 + L1;
            id L2 = L0 + L2;
            id L3 = -2*L0 + L3;
        #elseif (`FROM' == 2)&&(`TO' == N)
*             Bijnens, Colangelo & Ecker '99 eq. (3.16)
            id l1 = -2*L0 + 4*L1 + 2*L3;
            id l2 = 4*(L0 + L2);
            id l3 = 4*(-2*L4 - L5 + 4*L6 + 2*L8);
            id l4 = 4*(2*L4 + L5);
            id l5 = L10;
            id l6 = -2*L9;
            id l7 = -8*(2*L7 + L8);
        #elseif (`FROM' == 2)&&(`TO' == 3)
*             Deduced from the above
            id l1 = 4*L1 + 2*L3;
            id l2 = 4*L2;
            id l3 = 4*(-2*L4 - L5 + 4*L6 + 2*L8);
            id l4 = 4*(2*L4 + L5);
            id l5 = L10;
            id l6 = -2*L9;
            id l7 = -8*(2*L7 + L8);
        #else
            #message[invertcayham]~~~ Invalid: `FROM' -> `TO'
            #terminate
        #endif
    #elseif (`ORD' == 6)||(`ORD' == NNLO)
        #include- invert_cayham_`FROM'to`TO'.hf
    #else
        #message[invertcayham]~~~ Not supported: order `ORD'
    #endif
#endprocedure


#endif
