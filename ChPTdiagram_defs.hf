#ifndef `CHPTDIAGRAMDEFSHF'
#define CHPTDIAGRAMDEFSHF

* Definitions for the ChPT diagram library

* TODO: move the more specific of these to the header file containing the
*  procedures that actually use them.
* This works as long as all of ChPTdiagram.hf is always loaded,
*  and is much more maintainable.

********************************************************************************
* Setup, options and parameters

* Number of external particles
#call require(NEXT)

* GENeral PARametrization from the sixmeson paper
#ifdef `GENPAR'
    cfunction a;
#endif
* The parametrization U = i_ Phi + sqrt(1 - Phi^2) (omitting normalization)
* Only valid for NF=2
* KAL is for Kalman Szabo, whose preference for it prompted me to implement it.
#ifdef `KALPAR'
    #define NF "2"
#endif

* Options for masses
#ifdef `FULLMASS'
    #message[ChPTdiagram]~~~ ERROR: full-mass ChPT not supported yet!
    #terminate
#endif
* Three distinct masses: Pion, Kaon, Eta
#ifdef `PKEMASS'
    #define NF "3"
    cfunctions propmatrix, Prop,Prop8,Prop88;
    symbols mhat,ms;
    symbols mp2,mk2,me2, m0p2,m0k2,m0e2;
#else
    #define EQUALMASS
    symbols mp2, m0p2;
#endif

* Scalar QED + phi^4 is a neat reskin of ChPT
#ifdef `SQED'
    #message[ChPTdiagram]~~~ WARNING: scalar QED not fully supported!
    symbols e, lambda;
    function oppositeparity;
    cfunctions delZ,delM,delA,delE,delEE,delL;
#endif

* Number of flavors
#ifndef `NF'
    #define NFGENERAL
    #define NF "Nf"
    symbol Nf;
#else
    #if `NF'>3
        #define NFGENERAL
    #endif
#endif


********************************************************************************
* Internal momenta, Lorentz indices

indices mu,nu,ro,si,ka,la,al,be;
set lorentz: mu,nu,ro,si,ka,la,al,be;

#ifdef `LOOPMOMENTA'
    #do L={`LOOPMOMENTA'}
        vector `L';
        symbol [`L'^2-M^2];
    #enddo
    set loopmomenta:
        #do L={`LOOPMOMENTA'}
            ,`L'
        #enddo
        ;
#else
    #define LOOPMOMENTA "ell"
#endif

#ifndef `PROPMOMENTA'
    #define PROPMOMENTA "`LOOPMOMENTA'"
#endif
#do Q={`PROPMOMENTA'}
    vector `Q';
#enddo

#ifdef `INTMOMENTA'
    #do Q={`INTMOMENTA'}
        vector `Q';
        symbol `Q'sq;
        #do L={`LOOPMOMENTA'}
            vector [`L'+`Q'], [`L'-`Q'], [`Q'-`L'];
            symbol [(`L'+`Q')^2-M^2],[(`L'-`Q')^2-M^2];
            #redefine PROPMOMENTA "[`L'+`Q'],[`L'-`Q'],[`Q'-`L'],`PROPMOMENTA'"
        #enddo
    #enddo
#endif

set loops: `LOOPMOMENTA';

********************************************************************************
* Display preprocessor variables
* Importantly, do this BEFORE all the LECs and stuff are added

#ifndef `QUIET'
    #show
#endif

********************************************************************************
* LECs

symbol B0, M,F, Mpi,Fpi, MK,FK, Meta,Feta;
#define LECS "B0,F,Fpi"

#ifdef `NFGENERAL'
    #define NLOLECS "<L0,L0r>,...,<L10,L10r>,H1,H2,H1r,H2r"
    #define NNLOLECS "<K1,K1r>,...,<K115,K115r>,<Kt1>,...,<Kt16>"
    #define N3LOLECS "<K8x1,K8r1>,...,<K8x1862,K8r1862>"
#else
    #if `NF'==3
        #define NLECxNNLO "94"
        #define NLOLECS "<L0,L0r>,...,<L10,L10r>,H1,H2,H1r,H2r"
        #define NNLOLECS "<C1,C1r>,...,<C94,C94r>,<Ct1>,...,<Ct16>"
        #define N3LOLECS "<C8x1,C8r1>,...,<C8x1254,C8r1254>"
    #elseif `NF'==2
        #define NLOLECS "<l1,l1r,l1b>,...,<l8,l8r,l8b>,<L0>,...,<L10>,H1,H2,h1,h2,h3,h1r,h2r,h3r"
        #define NNLOLECS "<c1,c1r>,...,<c57,c57r>,<ct1>,...,<ct10>"
        #define N3LOLECS "<c8x1,c8r1>,...,<c8x475,c8r475>"
    #endif
#endif
* Generic dummy LECs
#define DUMMYLECS "p4LEC,p6LEC,p8LEC"
symbols `DUMMYLECS';
* All LECs
#ifdef `ORDER'
    #if `ORDER'>=4
        #redefine LECS "`LECS',`NLOLECS'"
    #endif
    #if `ORDER'>=6
        #redefine LECS "`LECS',`NNLOLECS'"
    #endif
    #if `ORDER'>=8
        #redefine LECS "`LECS',`N3LOLECS'"
    #endif
#else
    #redefine LECS "`LECS',`NLOLECS',`NNLOLECS',`N3LOLECS'"
#endif
symbols `LECS';
set LECs: `LECS';

********************************************************************************
* Loop integrals

autodeclare cfunction int;

cfunctions tadpole, bubble, triangle;
#define LOOPS "
    A,
    Ab,
    B, B1, B21,B22, B31,B32,
    Bb, B1b, B21b,B22b, B31b,B32b,
    C, Cx11,Cx12,Cx13, Cx21,Cx22,Cx23, Cx31,
    H, HH1, H21,H22,H23,H24,
    V, VV,
    Jbar"
cfunctions `LOOPS';

********************************************************************************
* External particles

#include- defaultext.hf

#ifndef `NOMANDEL'
    symbols s,t,u, [s-t],[t-u],[u-s], [t-s],[u-t],[s-u], [s+t],[t+u],[u+s], [t+s],[u+t],[s+u];
    set mandel: s,t,u, [s-t],[t-u],[u-s], [t-s],[u-t],[s-u], [s+t],[t+u],[u+s], [t+s],[u+t],[s+u];
#endif

indices flav,<f1=`NF'>,...,<f`NEXT'=`NF'>;
set extflav: <f1>,...,<f`NEXT'>;
vectors <p1>,...,<p`NEXT'>;
set extmomenta: <p1>,...,<p`NEXT'>;

indices <i1>,...,<i{`NEXT'*2}>;
vectors <q1>,...,<q{`NEXT'*2}>;

#if `NEXT' <= 4
    set extlorentz: mu,nu,ro,si;
#else
    indices <mu1>,...,<mu`NEXT'>;
    set extlorentz: <mu1>,...,<mu`NEXT'>;
#endif

function ext;
vectors <ext1>,...,<ext`NEXT'>;
set external: <ext1>,...,<ext`NEXT'>;

********************************************************************************
* Miscellaneous

functions Q, Phi;
functions tr,chi;
cfunctions Tr(cyclic), phi, A;
symbols n, <n1>,...,<n`NEXT'>, m, <m1>,...,<m`NEXT'>;
symbols sqrt2,sqrt3,sqrt6;

cfunctions prop, coeff;
functions sum, derivs, dummy;

symbols d, [d], <[d-1]>,...,<[d-4]>;
symbols kappa,L, eps,etil, log4pi;

function cross, mirror, cycle, permute, replace;

vectors p,q,k, p0,p1,p2,p3,p4;
symbol qsq, q1sq,q2sq,q3sq, beta;
indices i,j;
symbols sgn,mark;
symbol pi;

#ifdef `SQED'
    ctensors SQED,SQEDphi,SQEDdag;
#endif

********************************************************************************
* Standard bracket statement

#procedure stdbracket
    bracket i_,Tr,`LECS',`LOOPS', F,Fpi, int,prop
        #ifdef `SQED'
            ,e,lambda
        #endif
        ;
#endprocedure

#endif
