
#ifndef `SCHEME'
    #message[renorm]~~~ SCHEME not defined, defaulting to MSBAR (ChPT edition)
    #define SCHEME "MSBAR"
#endif

#procedure renormalize(EXPR,ORD,MAXEPS)

    .sort
    symbols [d],[d-1],[d-2],[d-3],[d-4];
    symbols [(cmu)^(d-4)], Lambda;
    skip; nskip `EXPR';

    #do N=2,8,2
        #if `ORD' == `NORDER`N''
            #redefine ORD "`N'"
            #breakdo
        #endif
    #enddo

    #if (isdefined(NORENORM)==0)&&(`ORD'<=`ORDER')
        #ifdef `SQED'
            id delA(4) = e^2/3 * i_*kappa*[expCtad0eps] / eps;
            id delEE(4) = 2*delE(4) - i_*delZ(4);
        #else
            #switch `ORD'
                #case 2
                    #break
                #case 4
                    #include- ChPTdiagram_p4renorm.hf
                    #break
                #case 6
                    #include- ChPTdiagram_p6renorm.hf
                    #break
                #case 8
                    #include- ChPTdiagram_p8renorm.hf
                    #break
                #default
                    #message[renorm]~~~ ERROR: order p^`ORD' not implemented
                    #terminate
            #endswitch
        #endif
    #endif

*     Renormalization scheme and associated conventions
    #switch `SCHEME'
*         ChPT variant of MSbar
        #case MSBAR
            .sort
            symbols ctil, etil;
            skip; nskip `EXPR';

            id [(cmu)^(d-4)]^m? = sum_(n,0,`MAXEPS', (m * eps * ctil)^n * invfac_(n));
            #break
*         Sjo, Vanhove et al. '25
        #case SV25
        #case SV25M
            .sort
            symbol musq;* mu and mu2 are already taken as indices
            cfunction C;
            skip; nskip `EXPR';

            id [(cmu)^(d-4)]^m? =
                #ifdef `MUisMP2'
                    C(eps,m0p2)^m
                #else
                    C(eps,musq)^m
                #endif
                * sum_(n,0,`MAXEPS', (m * eps)^n * invfac_(n));
            #break
*         Bijnens & Hermansson-Truedsson '17
        #case BHT17
            .sort
            symbol [Gam(1+eps)];
            cfunction C;
            skip; nskip `EXPR';

            id [(cmu)^(d-4)]^m? = C(eps,m0p2)^m * sum_(n,0,`MAXEPS', (m * eps * (L + 1 - gammaE))^n * invfac_(n)) / [Gam(1+eps)];
            #break
*         For debugging other things
        #case NULL
            id [(cmu)^(d-4)] = 1;
            #break
        #default
            #message[renorm]~~~ Unknown renormalization scheme `SCHEME'
            #terminate
    #endswitch
    id Lambda = kappa / [d-4];

    #call qrenorm
    #call expandD(`MAXEPS')

    #if `SCHEME' == MSBAR
*         Careful with the signs here
        id 1/eps = 1/etil - ctil;
        id eps/etil = 1 + eps*ctil;
    #endif

    .sort:>>renormalize `NORDER`ORD''<<;
#endprocedure

#procedure changemu(ORD,LOGRATIO)
* Change renormalization scale
* LOGRATIO is log( [new mu^2] / [old mu^2] )
* Higher orders must be done AFTER lower

* Implemented by piggy-backing on the renormalization,
*  guaranteeing that all coefficients are the same

    #define CHANGEMU "`LOGRATIO'"
    #call renormalize(`ORD',0)

#endprocedure

#procedure qrenorm()
*     Newer Bijnens "q" convention for the renormalized LECs,
*     absorbing annoying kappas from the "r" convention

    #if `ORDER'>`MFORDER'
        #define MAX "`ORDER'"
    #else
        #define MAX "`MFORDER'"
    #endif

    #ifdef `QRENORM'
        #do ORD=4,`MAX',2
            #do L={``NORDER`ORD''LECSBARE'}
                id `L'r = kappa^{(`ORD'-2)/2} * `L'q;
            #enddo
        #enddo
    #endif
#endprocedure

#procedure massdecay(EXPR)
    .sort
    skip; nskip `EXPR';

    #ifdef `PKEMASS'
        id m0e2 = 4/3*m0k2 - 1/3*m0p2;

        #if `MFORDER' == 2
            id m0p2 = mp2;
            id m0k2 = mk2;
            id 1/F = 1/Fp;
        #elseif `MFORDER' == 4
            .sort
            symbols Mpp,Mpk,Mkp,Mkk, xi;
            skip; nskip `EXPR';

*             Mab is the coefficient of m0a2*m0b2 in the expression for ma2.
*             The below formula follows from inverting that relation.

*             xi is a power-counting parameter like in the equal-mass case below,
*             except that the kappa*mass is excluded from it

            id m0p2^n? = mp2^n * (1 - n*xi * (Mpp*mp2 + Mpk*mk2));
            id m0k2^n? = mk2^n * (1 - n*xi * (Mkp*mp2 + Mkk*mk2));

*             From Gasser & Leutwyler '85 via Gomez-Nicola & Pelaez '01
            id Mpp =
                    + 1/2 * Lp*kappa
                    + 1/18 * Le*kappa
                    + 8 * (2*L6r + 2*L8r - L4r - L5r);
            id Mpk =
                    - 2/9 * Le*kappa
                    + 16 * (2*L6r - L4r);
            id Mkp =
                    - 1/9 * Le*kappa
                    + 8*(2*L6r - L4r);
            id Mkk =
                    + 4/9 * Le*kappa
                    + 8*(4*L6r + 2*L8r - 2*L4r - L5r);

            .sort
            skip; nskip `EXPR';

*             Similar story with the decay constant, but simpler since we only use Fp.

            id 1/F^n? = 1/Fp^n * (1 + n*xi * (
                - Lp*mp2*kappa
                - 1/2 * Lk*mk2*kappa
                + 4*mp2 * (L4r + L5r)
                + 8*mk2 * L4r
                ));

            .sort
            skip; nskip `EXPR';

*             Truncate the power-counting
*             (effectively make it NLO in mass XOR decay constant, not OR)
            if(count(xi,1) > 1) discard;
            id xi = 1/Fp^2;

        #else
            #message[massdecay]~~~ PKE mass not supported above NLO
            #terminate
        #endif
    #elseif `MFORDER' == 2
        id m0p2^n? = mp2^n;
        id F^n? = Fp^n;
    #else
        .sort
        cfunctions dM, dF;
        symbol xi;
        autodeclare symbol aM,bM, aF,bF;

        skip; nskip `EXPR';

        #define XIMAX "{`MFORDER'/2-1}"

*         Write "bare -> physical" as a series in x
        id m0p2^n? = mp2^n * (1 + <xi^1*dM(1,n)>+...+<xi^`XIMAX'*dM(`XIMAX',n)>);
        id F^n?    = Fp^n  * (1 + <xi^1*dF(1,n)>+...+<xi^`XIMAX'*dF(`XIMAX',n)>);

*         Write in terms of b coefficients
        #do Q={M,F}
            id d`Q'(1,n?) = n*d`Q'(1);
            id d`Q'(2,n?) = n*d`Q'(2) + n*(n-1)/2 * d`Q'(1)^2;
            id d`Q'(3,n?) = n*d`Q'(3) + n*(n-1) * d`Q'(1)*d`Q'(2) + n*(n-1)*(n-2)/6 * d`Q'(1)^3;

            #do I=1,`XIMAX'
                id d`Q'(`I') =
                    #do J=0,`I'
                        + Lp^`J' * b`Q'`I'`J'
                    #enddo
                    ;
            #enddo
        #enddo

*         Truncate at appropriate order
        if(count(xi,1)>`XIMAX') discard;
        id xi = kappa * mp2/Fp^2;

*         Translate to the a coefficients of the original relation
        #include- invert_massdecay.hf

        .sort
        skip; nskip `EXPR';

*         Get terms from prior work
        #if `NF' == 2
            #include- ChPTdiagram_massdecay_NF2.hf
        #else
            #include- ChPTdiagram_massdecay_NFN.hf
        #endif
    #endif
    #call qrenorm
    .sort:>>`NORDER`MFORDER'' M,F `EXPR'<<;
#endprocedure

#procedure Zrenorm(EXPR):
*     Ensure information exists about the type of external particle
    #ifndef `PKELIST'
        #ifdef `FLAVS'
            #define PKELIST "`PKE`FLAVS''"
            #message[Zrenorm]~~~ PKELIST not defined, defaulting via FLAVS to PKE`FLAVS'
        #else
            #message[Zrenorm]~~~ ERROR: Zrenorm needs PKELIST (or FLAVS) defined
            #terminate
        #endif
    #endif

    .sort
    symbol lambda;
    #do ORD=4,`ZORDER'
        symbols Zp`NORDER`ORD''
            #ifdef `PKEMASS'
                , Zk`NORDER`ORD'', Ze`NORDER`ORD''
            #endif
            ;
    #enddo
    skip; nskip `EXPR';

    multiply (0
        #do X={`PKELIST'}
            #if `ZORDER' > 2
                + Z`X'NLO/(2*F^2)
                #if `ZORDER' > 4
*                     - Z`X'NNLO/(8*F^4)
                    #message[Zrenorm]~~~ Zrenorm not implemented beyond NLO
                #endif
            #endif
        #enddo
        );

    #ifdef `PKEMASS'
*         From Gomez Nicola & Pelaez '01
*         with lambda = -kappa/2/etil in Bijnens' convention
*         GN&P are also a little inconsistent regatding m0 vs m, but that doesn't
*         matter until NNLO
        id ZpNLO
            = 2*m0p2*Lp*kappa/3
            + 1*m0k2*Lk*kappa/3
            - 4*lambda/3 * (2*m0p2 + m0k2)
            - 8*(2*L4r*m0k2 + (L4r+L5r)*m0p2);
        id ZkNLO
            = m0p2*Lp*kappa/4
            + m0k2*Lk*kappa/2
            + m0e2*Le*kappa/4
            - 2*lambda/3 * (m0p2 + 5*m0k2)
            - 8*((2*L4r+L5r)*m0k2 + L4r*m0p2);
        id ZeNLO
            = m0k2*Lk*kappa
            - 4*lambda*m0k2
            - 8/3*((3*L4r-L5r)*m0p2 + 2*(3*L4r+2*L5r)*m0k2);
    #else
*         Bijnens' modus operandi is computing these on the fly
    #endif


#endprocedure

#procedure expandD(MAXEPS)

    id pi^2 = 1/(16*kappa);
    id 1/pi^2 = 16*kappa;

    id d^n? = [d]^n;

    id [d]   = 4 - 2*eps;
    id [d-1] = 3 - 2*eps;
    id [d-2] = 2 - 2*eps;
    id [d-3] = 1 - 2*eps;
    id [d-4] =   - 2*eps;
    id 1/[d-4] = 1/(-2*eps);
    id 1/[d-3] =       sum_(n,0,`MAXEPS', (2*eps)^n);
    id 1/[d-2] = 1/2 * sum_(n,0,`MAXEPS', eps^n );
    id 1/[d-1] = 1/3 * sum_(n,0,`MAXEPS', (2/3 * eps)^n );
    id 1/[d]   = 1/4 * sum_(n,0,`MAXEPS', (eps/2)^n);

#endprocedure
