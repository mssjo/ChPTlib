
#ifndef `SCHEME'
    #message[renorm]~~~ SCHEME not defined, defaulting to MSBAR (ChPT edition)
    #define SCHEME "MSBAR"
#endif

#procedure renormalize(ORD,MAXEPS)

    .sort
    symbols [d],[d-1],[d-2],[d-3],[d-4];
    symbols [(cmu)^(d-4)], Lambda;

    #do N=2,8,2
        #if `ORD' == `NORDER`N''
            #redefine ORD "`N'"
            #breakdo
        #endif
    #enddo

    #if (isdefined(NORENORM)==0)&&(`ORD'<=`ORDER')
        #ifdef `SQED'
            id delA(4) = e^2/3 * i_*kappa*[expCtad0eps] / eps;
            id delEE(4) = 2*delE(4) - i_*delZ(4);
        #else
            #switch `ORD'
                #case 2
                    #break
                #case 4
                    #include- ChPTdiagram_p4renorm.hf
                    #break
                #case 6
                    #include- ChPTdiagram_p6renorm.hf
                    #break
                #case 8
                    #include- ChPTdiagram_p8renorm.hf
                    #break
                #default
                    #message[renorm]~~~ ERROR: order p^`ORD' not implemented
                    #terminate
            #endswitch
        #endif
    #endif

    .sort

*     Renormalization scheme and associated conventions
    #switch `SCHEME'
*         ChPT variant of MSbar
        #case MSBAR
            symbol ctil;
            id [(cmu)^(d-4)]^m? = sum_(n,0,`MAXEPS', (m * eps * ctil)^n * invfac_(n));
            #break
*         Sjo, Vanhove et al. '25
        #case SV25
        #case SV25M
            symbol musq;* mu and mu2 are already taken as indices
            cfunction C;
            id [(cmu)^(d-4)]^m? =
                #ifdef `MUisMP2'
                    C(eps,m0p2)^m
                #else
                    C(eps,musq)^m
                #endif
                * sum_(n,0,`MAXEPS', (m * eps)^n * invfac_(n));
            #break
*         Bijnens & Hermansson-Truedsson '17
        #case BHT17
            symbol [Gam(1+eps)];
            cfunction C;
            id [(cmu)^(d-4)]^m? = C(eps,m0p2)^m * sum_(n,0,`MAXEPS', (m * eps * (L + 1 - gammaE))^n * invfac_(n)) / [Gam(1+eps)];
            #break
*         For debugging other things
        #case NULL
            id [(cmu)^(d-4)] = 1;
            #break
        #default
            #message[renorm]~~~ Unknown renormalization scheme `SCHEME'
            #terminate
    #endswitch
    id Lambda = kappa / [d-4];

    #call qrenorm
    #call expandD(`MAXEPS')

    .sort:>>renormalize `NORDER`ORD''<<;
#endprocedure

#procedure changemu(ORD,LOGRATIO)
* Change renormalization scale
* LOGRATIO is log( [new mu^2] / [old mu^2] )
* Higher orders must be done AFTER lower

* Implemented by piggy-backing on the renormalization,
*  guaranteeing that all coefficients are the same

    #define CHANGEMU "`LOGRATIO'"
    #call renormalize(`ORD',0)

#endprocedure

#procedure qrenorm()
*     Newer Bijnens "q" convention for the renormalized LECs,
*     absorbing annoying kappas from the "r" convention

    #if `ORDER'>`MFORDER'
        #define MAX "`ORDER'"
    #else
        #define MAX "`MFORDER'"
    #endif

    #ifdef `QRENORM'
        #do ORD=4,`MAX',2
            #do L={``NORDER`ORD''LECSBARE'}
                id `L'r = kappa^{(`ORD'-2)/2} * `L'q;
            #enddo
        #enddo
    #endif
#endprocedure

#procedure massdecay(EXPR)
    .sort
    skip; nskip `EXPR';

    #ifdef `PKEMASS'
        id m0e2 = 4/3*m0k2 - 1/3*m0p2;

        #if `MFORDER' == 2
            id m0p2 = mp2;
            id m0k2 = mk2;
            id 1/F = 1/Fp;
        #elseif `MFORDER' == 4
            .sort
            symbols Mpp,Mpk,Mkp,Mkk;
            skip; nskip `EXPR';

*             Mab is the coefficient of m0a2*m0b2 in the expression for ma2.
*             The below formula follows from inverting that relation.

            id m0p2^n? = mp2^n * (1 - n/Fp^2 * (Mpp*mp2 + Mpk*mk2));
            id m0k2^n? = mk2^n * (1 - n/Fp^2 * (Mkp*mp2 + Mkk*mk2));

*             From Gasser & Leutwyler '85 via Gomez-Nicola & Pelaez '01
            id Mpp =
                    + 1/2 * Lp*kappa
                    + 1/18 * Le*kappa
                    + 8 * (2*L6r + 2*L8r - L4r - L5r);
            id Mpk =
                    - 2/9 * Le*kappa
                    + 16 * (2*L6r - L4r);
            id Mkp =
                    - 1/9 * Le*kappa
                    + 8*(2*L6r - L4r);
            id Mkk =
                    + 4/9 * Le*kappa
                    + 8*(4*L6r + 2*L8r - 2*L4r - L5r);

            .sort
            skip; nskip `EXPR';

*             Similar story with the decay constant, but simpler since we only use Fp.

            id 1/F^n? = 1/Fp^n * (1 + n/Fp^2 * (
                - Lp*mp2*kappa
                - 1/2 * Lk*mk2*kappa
                + 4*mp2 * (L4r + L5r)
                + 8*mk2 * L4r
                ));

        #else
            #message[massdecay]~~~ PKE mass not supported above NLO
            #terminate
        #endif
    #elseif `MFORDER' == 2
        id m0p2^n? = mp2^n;
        id F^n? = Fp^n;
    #else
        .sort
        cfunctions dM, dF;
        symbol xi;
        autodeclare symbol aM,bM, aF,bF;

        skip; nskip `EXPR';

        #define XIMAX "{`MFORDER'/2-1}"

*         Write "bare -> physical" as a series in x
        id m0p2^n? = mp2^n * (1 + <xi^1*dM(1,n)>+...+<xi^`XIMAX'*dM(`XIMAX',n)>);
        id F^n?    = Fp^n  * (1 + <xi^1*dF(1,n)>+...+<xi^`XIMAX'*dF(`XIMAX',n)>);

*         Write in terms of b coefficients
        #do Q={M,F}
            id d`Q'(1,n?) = n*d`Q'(1);
            id d`Q'(2,n?) = n*d`Q'(2) + n*(n-1)/2 * d`Q'(1)^2;
            id d`Q'(3,n?) = n*d`Q'(3) + n*(n-1) * d`Q'(1)*d`Q'(2) + n*(n-1)*(n-2)/6 * d`Q'(1)^3;

            #do I=1,`XIMAX'
                id d`Q'(`I') =
                    #do J=0,`I'
                        + Lp^`J' * b`Q'`I'`J'
                    #enddo
                    ;
            #enddo
        #enddo

*         Truncate at appropriate order
        if(count(xi,1)>`XIMAX') discard;
        id xi = kappa * mp2/Fp^2;

*         Translate to the a coefficients of the original relation
        #include- invert_massdecay.hf

        .sort
        skip; nskip `EXPR';

*         Get terms from prior work
        #if `NF' == 2
            #include- ChPTdiagram_massdecay_NF2.hf
        #else
            #include- ChPTdiagram_massdecay_NFN.hf
        #endif
    #endif
    #call qrenorm
    .sort:>>`NORDER`MFORDER'' M,F `EXPR'<<;
#endprocedure

#procedure expandD(MAXEPS)

    id pi^2 = 1/(16*kappa);
    id 1/pi^2 = 16*kappa;

    id d^n? = [d]^n;

    id [d]   = 4 - 2*eps;
    id [d-1] = 3 - 2*eps;
    id [d-2] = 2 - 2*eps;
    id [d-3] = 1 - 2*eps;
    id [d-4] =   - 2*eps;
    id 1/[d-4] = 1/(-2*eps);
    id 1/[d-3] =       sum_(n,0,`MAXEPS', (2*eps)^n);
    id 1/[d-2] = 1/2 * sum_(n,0,`MAXEPS', eps^n );
    id 1/[d-1] = 1/3 * sum_(n,0,`MAXEPS', (2/3 * eps)^n );
    id 1/[d]   = 1/4 * sum_(n,0,`MAXEPS', (eps/2)^n);

#endprocedure
