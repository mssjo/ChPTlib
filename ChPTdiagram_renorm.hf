#procedure renormalize(ORD,MAXEPS)

    .sort
    symbols [d],[d-1],[d-2],[d-3],[d-4];
    symbols [(cmu)^(d-4)], Lambda, ctil;
    #ifdef `PMCONV'
        cfunction C;
    #endif
    #ifdef `HNCONV'
        symbol [Gam(1+eps)];
        cfunction C;
    #endif

    #do N=2,8,2
        #if `ORD' == `NORDER`N''
            #redefine ORD "`N'"
            #breakdo
        #endif
    #enddo

    #if (isdefined(NORENORM)==0)&&(`ORD'<=`ORDER')
        #ifdef `SQED'
            id delA(4) = e^2/3 * i_*kappa*[expCtad0eps] / eps;
            id delEE(4) = 2*delE(4) - i_*delZ(4);
        #else
            #switch `ORD'
                #case 2
                    #break
                #case 4
                    #include- ChPTdiagram_p4renorm.hf
                    #break
                #case 6
                    #include- ChPTdiagram_p6renorm.hf
                    #break
                #case 8
                    #include- ChPTdiagram_p8renorm.hf
                    #break
                #default
                    #message[renorm]~~~ ERROR: order p^`ORD' not implemented
                    #terminate
            #endswitch
        #endif
    #endif

    #if isdefined(PMCONV)
        id [(cmu)^(d-4)]^m? = C(eps,mu)^m * sum_(n,0,`MAXEPS', (m * eps)^n * invfac_(n));
    #elseif isdefined(HNCONV)
        id [(cmu)^(d-4)]^m? = C(eps,mp2)^m * sum_(n,0,`MAXEPS', (m * eps * (L + 1 - gammaE))^n * invfac_(n)) / [Gam(1+eps)];
    #elseif isdefined(PLAINCONV)
        id [(cmu)^(d-4)] = 1;
    #else
        id [(cmu)^(d-4)]^m? = sum_(n,0,`MAXEPS', (m * eps * ctil)^n * invfac_(n));
    #endif

    id Lambda = kappa / [d-4];

    #call qrenorm
    #call expandD(`MAXEPS')

    .sort:>>renormalize `NORDER`ORD''<<;
#endprocedure

#procedure qrenorm()
*     Bijnens "q" convention for the renormalized LECs,
*     absorbing annoying kappa's from the "r" convention
    #ifdef `QRENORM'
        #do ORD=4,`ORDER',2
            #do L={``NORDER`ORD''LECSBARE'}
                id `L'r = kappa^{(`ORD'-2)/2} * `L'q;
            #enddo
        #enddo
    #endif
#endprocedure

#procedure massdecay(EXPR,ORD)
    #do N=2,8,2
        #if `ORD' == `NORDER`N''
            #redefine ORD "`N'"
            #breakdo
        #endif
    #enddo

    .sort
    skip; nskip `EXPR';

    #ifdef `PKEMASS'
        id m0e2 = 4/3*m0k2 - 1/3*m0p2;

        #if `ORD' == 2
            id m0p2 = mp2;
            id m0k2 = mk2;
            id 1/F = 1/Fp;
        #elseif `ORD' == 4
            .sort
            symbols Mpp,Mpk,Mkp,Mkk;
            skip; nskip `EXPR';

*             Mab is the coefficient of m0a2*m0b2 in the expression for ma2.
*             The below formula follows from inverting that relation.

            id m0p2^n? = mp2^n * (1 - n/Fp^2 * (Mpp*mp2 + Mpk*mk2));
            id m0k2^n? = mk2^n * (1 - n/Fp^2 * (Mkp*mp2 + Mkk*mk2));

*             From Gasser & Leutwyler '85 via Gomez-Nicola & Pelaez '01
            id Mpp =
                    + 1/2 * Lp*kappa
                    + 1/18 * Le*kappa
                    + 8 * (2*L6r + 2*L8r - L4r - L5r);
            id Mpk =
                    - 2/9 * Le*kappa
                    + 16 * (2*L6r - L4r);
            id Mkp =
                    - 1/9 * Le*kappa
                    + 8*(2*L6r - L4r);
            id Mkk =
                    + 4/9 * Le*kappa
                    + 8*(4*L6r + 2*L8r - 2*L4r - L5r);

            .sort
            skip; nskip `EXPR';

*             Similar story with the decay constant, but simpler since we only use Fp.

            id 1/F^n? = 1/Fp^n * (1 + n/Fp^2 * (
                - Lp*mp2*kappa
                - 1/2 * Lk*mk2*kappa
                + 4*mp2 * (L4r + L5r)
                + 8*mk2 * L4r
                ));

        #else
            #message[massdecay]~~~ PKE mass not supported above NLO
            #terminate
        #endif
    #elseif `ORD' == 2
        id m0p2 = mp2;
        id 1/F = 1/Fp;
    #else
        .sort
        cfunctions dM, dF;
        symbol xi;
        autodeclare symbol aM,bM, aF,bF;
        skip; nskip `EXPR';

        #define XMAX "{`ORD'/2-1}"

*         Write "bare -> physical" as a series in x
        id m0p2^n? = mp2^n * (1 + <xi^1*dM(1,n)>+...+<xi^`XMAX'*dM(`XMAX',n)>);
        id F^n?    = Fp^n  * (1 + <xi^1*dF(1,n)>+...+<xi^`XMAX'*dF(`XMAX',n)>);

*         Write in terms of b coefficients
        #do Q={M,F}
            id d`Q'(1,n?) = n*d`Q'(1);
            id d`Q'(2,n?) = n*d`Q'(2) + n*(n-1)/2 * d`Q'(1)^2;
            id d`Q'(3,n?) = n*d`Q'(3) + n*(n-1) * d`Q'(1)*d`Q'(2) + n*(n-1)*(n-2)/6 * d`Q'(1)^3;

            #do I=1,`XMAX'
                id d`Q'(`I') =
                    #do J=0,`I'
                        + Lp^`J' * b`Q'`I'`J'
                    #enddo
                    ;
            #enddo
        #enddo

*         Truncate at appropriate order
        if(count(xi,1)>`XMAX') discard;
        id xi = kappa * mp2/Fp^2;

*         Translate to the a coefficients of the original relation
        #include- invert_massdecay.hf

        .sort
        skip; nskip `EXPR';

*         Get terms from prior work
        #if `NF' == 2
*             Bijnens & Hermansson-Truedsson '17

            #if `ORD' >= 4
                #call require(QRENORM)
                id aM10 = (2*l3q);
                id aM11 = (1/2);
                id aF10 = (l4q);
                id aF11 = (-1);
            #endif

            #if `ORD' >= 6
                id aM20 = (
                    64*c18q + 32*c17q + 96*c11q + 48*c10q - 16*c9q - 32*c8q - 16*c7q - 32*c6q + l3q + 2*l2q + l1q + 163/96);
                id aM21 = (-3*l3q - 8*l2q - 14*l1q - 49/12);
                id aM22 = (17/8);
                id aF20 = (
                    8*c9q + 16*c8q + 8*c7q - 2*l3q - l2q - 1/2*l1q - 13/192);
                id aF21 = (-1/2*l4q - 2*l3q + 4*l2q + 7*l1q + 23/12);
                id aF22 = (-5/4);
            #endif

            #if `ORD' >= 8
                .sort
                symbols rM8q, rF8q, zeta3;
                skip; nskip `EXPR';

                id aM30 = (
                    rM8q - 3*l3q*c9q - 64*l3q*c8q - 32*l3q*c7q - 128*l3q*c6q + 32*c18q + 16*c17q - 4*c13q + 24*c12q + 48*c11q + 24*c10q - 8*c9q - 16*c8q - 8*c7q - 40*c6q + 12*c5q + 4*c4q - 8*c3q - 7*l3q^2 - 22*l1q*l3q - 4*l2q*l3q + 157/48*l3q + 8651/1200*l2q + 3823/1200*l1q + 4869659/777600 - 13/6*zeta3);
                id aM31 = (
                    -416*c18q - 208*c17q - 32*c16q + 96*c14q + 8*c13q - 48*c12q - 384*c11q - 192*c10q + 72*c9q + 144*c8q + 72*c7q + 64*c6q - 8*c5q - 56*c4q + 16*c3q + 32*c2q - 96*c1q - 8*l3q^2 -48*l2q*l3q - 84*l2q*l3q - 84*l1q*l3q - 88/3*l3q - 231/10*l2q - 69/5*l1q - 74971/8640);
                id aM32 = (32/2*l3q - 11*l2q - 38*l1q - 91/24);
                id aM33 = (103/24);
                id aF30 = (
                        rF8q - 8*l4q*c9q - 16*l4q*c8q - 8*l4q*c7q - 32*l4q*c6q - 64*c18q - 32*c17q + c13q - 6*c12q - 96*c11q - 48*c10q + 16*c9q + 32*c8q + 16*c7q + 40*c6q - 6*c5q - 2*c4q + 2*c3q - l3q*l4q - 2*l3q^2 + l2q*l4q + 4*l2q*l3q + 1/2*l1q*l4q + 12*l1q*l3q + 313/192*l4q + 241/48*l3q + 1469/800*l2q + 2359/600*l1q - 383293667/1555200 + 8/9*zeta3);
                id aF31 = (
                        -16*c20q - 64*c18q - 32*c17q + 8*c16q - 24*c14q - 2*c13q +12*c12q - 96*c11q - 48*c10q + 80*c6q + 4*c5q + 28*c4q - 4*c3q - 8*c2q + 24*c1q - l3q*l4q - 4*l2q*l4q + 16*l2q*l3q - 7*l1q*l4q + 28*l1q*l3q - 13/6*l4q + 17/2*l3q + 569/60*l2q + 77/10*l1q - 7499/2160);
                id aF32 = (3/8*l4q + 27/2*l2q + 33*l1q + 1037/144);
                id aF33 = (-83/24);

*                 TODO: determine rq from contact diagram
                #message[massdecay]~~~ WARNING: N3LO LECs rM8q, rF8q not known
            #endif

            #if `ORD' >= 10
                #message[massdecay]~~~ Not supported above N3LO
                #terminate
            #endif
        #else
*             Bijnens & Lu '09
*             Written differently from '17, with Abar = -m0p2*kappa*L0
*              and clumsier kappa management, so we convert them here.

            #if `ORD' >= 4
                id aM10 =
                    + 1/kappa * (
                        8*`NF'*(2*L6r - L4r) + 8*(2*L8r - L5r))
                    ;* bM/kappa
                id aM11 = 1/`NF'
                    ;* -aM
                id aF10 =
                    + 1/kappa * (
                        4*`NF'*L4r + 4*L5r)
                    ;* bF/kappa
                id aF11 = -`NF'/2
                    ;* -aF
            #endif

            #if `ORD' >= 6
                id aM20 =
                    + 1/kappa^2 * (
                        -32*K17r - 16*K19r - 16*K23r + 48*K25r + 32*K39r
                        + `NF'*(-32*K18r - 16*K20r - 16*K21r + 48*K26r + 32*K40r)
                        + `NF'^2*(-16*K22r + 48*K27r)
                        + 64*(`NF'*L4r + L5r)*(`NF'*L4r + L5r - 2*`NF'*L6r - 2*L8r))
                    + 1/kappa * (
                        -4/`NF'*(L0r + L3r) + 4*L1r + 2*`NF'*(2*L0r + L3r) + 2*`NF'^2*L2r
                        -8*(L4r - 2*L6r + 1/`NF'*(L5r-2*L8r)))
                    + (-1/16 + 3/16*1/`NF'^2 - 3/16*1/`NF' + 193/384*`NF' + 169/384*`NF'^2)
                    ;* fM/kappa^2 + gM/kappa + hM
                id aM21 =
                    - 1/kappa * (
                        8*L0r*(-3/`NF' + `NF') + 8*L1r*(-1 + 2*`NF'^2) + 4*L2r*(4 + `NF'^2) + L3r*(-24/`NF' + 20*`NF') + L4r*(40 - 16*`NF'^2) + L5r*(40/`NF' - 16*`NF') + L6r*(-16 + 16*`NF'^2) + L8r*(-80/`NF' + 32*`NF'))
                    - (-5/3 * 4/`NF'^2 + 19/16*`NF'^2)
                    ;* -dM/kappa - eM
                id aM22 =
                    -1/2 + 9/2/`NF'^2 + 3/8*`NF'^2
                    ;* cM
                id aF20 =
                    + 1/kappa^2 * (
                        -8*(`NF'*L4r + L5r)^2 + 8*(K19r + K23r) + 8*`NF'*(K20r + K21r) + 8*`NF'^2*K22r)
                    + 1/kappa * (
                        2/`NF'*(L0r + L3r) - 2*L1r + `NF'*(-2*L0r - L3r - 4*L5r - 8*L8r) + `NF'^2*(-L2r + 4*L4r - 8*L6r))
                    + (-7/24 + 7/8/`NF'^2 + `NF'^2/768)
                    ;* fF/kappa^2 + gF/kappa + hF
                id aF21 =
                    - 1/kappa * (
                        4/`NF'*(3*L0r + 3*L3r - L5r) + 4*L1r - 8*L2r - 4*L4r + `NF'*(-4*L0r - 10*L3r - 2*L5r + 8*L8r))
                    - (2/3 - 1/2/`NF'^2 - 59/96*`NF'^2)
                    ;* -dF/kappa - eF
                id aF22 =
                    -1/2 - 3/16*`NF'^2
                    ;* cF
            #endif

            #if `ORD' >= 8
                #message[massdecay]~~~ N3LO only supported for NF=2
                #terminate
            #endif
        #endif
    #endif
    #call qrenorm
    .sort:>>`NORDER`ORD'' M,F `EXPR'<<;
#endprocedure

#procedure expandD(MAXEPS)

    id pi^2 = 1/(16*kappa);
    id 1/pi^2 = 16*kappa;

    id [d] = 4 - 2*eps;
    id [d-1] = 3 - 2*eps;
    id [d-2] = 2 - 2*eps;
    id [d-3] = 1 - 2*eps;
    id [d-4] =   - 2*eps;
    id 1/[d-4] = 1/(-2*eps);
    id 1/[d-3] = sum_(n,0,`MAXEPS', (2*eps)^n);
    id 1/[d-2] = 1/2 * sum_(n,0,`MAXEPS', eps^n );
    id 1/[d-1] = 1/3 * sum_(n,0,`MAXEPS', (2/3 * eps)^n );
    id 1/[d] = 1/4 * sum_(n,0,`MAXEPS', (eps/2)^n);

#endprocedure
