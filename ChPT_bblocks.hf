* Header file for bblock-related things

* Define the applicable field counters.
* This is done in such a way that ChPT_bbexpand.frm and ChPT_lagrexpand.frm
*  don't have to check for HASVECTOR or HASSCALAR: all macros work in all cases,
*  with trivial values when they refer to non-included particles.
* For each particle type X, the total count NX is renamed to NNX
*  and NX is repurposed as a partial count for subdividing NNX.
* This simplified recursion, since the partial count becomes the total one
*  in subordinate calls.
* Also defined here are complements NXC of the partial count,
*  various macros for wildcarding and selecting subsets of counts,
*  and procedures which loop LOOPBODY over all subdivisions of the counts.
#define SPURIONS "V,A,S,P"
#define FIELDTYPES "M,`SPURIONS'"
#do X={`FIELDTYPES'}
    #ifndef `N`X''
        #define N`X' "0"
    #else
        #define HAS`X'
    #endif
    #define NN`X' "`N`X''"
    #define N`X'C "XXX"
#enddo
#define FIELDS "`~NM',`~NV',`~NA',`~NS',`~NP'"
#define FIELDSCOMPL "`~NMC',`~NVC',`~NAC',`~NSC',`~NPC'"
#define MESONONLY "`~NM',0,0,0,0"
#define MESONCOMPL "`~NMC',0,0,0,0"
#define VECTORONLY "0,`~NV',`~NA',0,0"
#define VECTORCOMPL "0,`~NVC',`~NAC',0,0"
#define SCALARONLY "0,0,0,`~NS',`~NP'"
#define SCALARCOMPL "0,0,0,`~NSC',`~NPC'"
#define NNVECTOR "{`NNV'+`NNA'}"
#define NNSCALAR "{`NNS'+`NNP'}"
#define FIELDSQ "NM?,NV?,NA?,NS?,NP?"
#define FIELDSV "NM,NV,NA,NS,NP"
#define DELTA(m,v,a,s,p) "delta_(NM,`~m')*delta_(NV,`~v')*delta_(NA,`~a')*delta_(NS,`~s')*delta_(NP,`~p')"

* Looping procedures expect LOOPBODY to be defined before,
* using appropriately delayed substitution for the loop variables
#procedure mesonloop()
    #do NM=0,`NNM'
        #define NMC "{`NNM'-`NM'}"
        `LOOPBODY'
    #enddo
#endprocedure
#procedure vectorloop()
    #do NV=0,`NNV'
        #define NVC "{`NNV'-`NV'}"
        #do NA=0,`NNA'
            #define NAC "{`NNA'-`NA'}"
            #define NVECTOR "{`NV'+`NA'}"
            `LOOPBODY'
        #enddo
    #enddo
#endprocedure
#procedure scalarloop()
    #do NS=0,`NNS'
        #define NSC "{`NNS'-`NS'}"
        #do NP=0,`NNP'
            #define NPC "{`NNA'-`NA'}"
            #define NSCALAR "{`NS'+`NP'}"
            `LOOPBODY'
        #enddo
    #enddo
#endprocedure
* Loop over all fields present by nesting the above looping procedures
#procedure fieldloop()
*   This beautiful solution fails due to some FORM quirk
*     #define SCALARLOOPBODY "`~LOOPBODY'"
*     #ifdef `HASSCALAR'
*         #define VECTORLOOPBODY "
*             #call scalarloop()"
*     #else
*         #define NSCALAR "0"
*         #define VECTORLOOPBODY "`~SCALARLOOPBODY'"
*     #endif
*     #ifdef `HASVECTOR'
*         #define MESONLOOPBODY "
*             #call vectorloop()"
*     #else
*         #define NVECTOR "0"
*         #define MESONLOOPBODY "`~VECTORLOOPBODY'"
*     #endif
*     #call mesonloop()
    #do NM=0,`NNM'
        #define NMC "{`NNM'-`NM'}"
        #do NV=0,`NNV'
            #define NVC "{`NNV'-`NV'}"
            #do NA=0,`NNA'
                #define NAC "{`NNA'-`NA'}"
                #define NVECTOR "{`NV'+`NA'}"
                #do NS=0,`NNS'
                    #define NSC "{`NNS'-`NS'}"
                    #do NP=0,`NNP'
                        #define NPC "{`NNA'-`NA'}"
                        #define NSCALAR "{`NS'+`NP'}"
                        `LOOPBODY'
                    #enddo
                #enddo
            #enddo
        #enddo
    #enddo
#endprocedure

* Standard imports
#define NEXT "0"
#do X={`FIELDTYPES'}
    #redefine NEXT "{`NEXT'+`N`X''}"
#enddo
#define NOMANDEL
#include ChPT_utils.hf
#include ChPT_defs.hf

#if `PAR'==SQRT
    cfunction sqrtcoeff;
#endif

* Name relevant things
#include- names.hf

* Define building blocks
* Building blocks are grouped by rank (number of Lorentz indices)
* Extra indices beyond the basic rank indicate appropriate derivatives
* Rank-0 u and rank-1 u are separate objects
* Weird rank-1 chip/chim from the p6 lagrangian are chipx/chimx
#define BBLOCKS0 "u,udag,chi,chidag,chip,U,Udag"
#define BBLOCKS1 "Gamma,u,U,Udag"
#define BBLOCKMAXRANK "{`ORDER'/2}"
#if `ORDER' >= 4
    #redefine BBLOCKS0 "`BBLOCKS0',chim"
    #define BBLOCKS2 "fp,fm,FL,FR"
    #ifdef `NF'
        #if `NF'==2
            #redefine BBLOCKS0 "`BBLOCKS0',chitil,chitildag"
            #redefine BBLOCKS2 "`BBLOCKS2',U,Udag"
        #endif
    #endif
#endif
#if `ORDER' >= 6
    #redefine BBLOCKS1 "`BBLOCKS1',chipx,chimx,chip,chim,chi,chidag"
    #redefine BBLOCKS2 "`BBLOCKS2',h,u"
    #define BBLOCKS3 "FL,FR,fp,fm"
    #ifdef `NF'
        #if `NF'==3
            #redefine BBLOCKS0 "`BBLOCKS0',chitil,chitildag"
        #elseif `NF'==2
            #redefine BBLOCKS1 "`BBLOCKS1',chi,chidag,chitil,chitildag"
        #endif
    #endif
#endif
#if `ORDER' >= 8
    #redefine BBLOCKS2 "`BBLOCKS2',chi,chidag,chip,chim"
    #redefine BBLOCKS3 "`BBLOCKS3',u,chip,chim"
    #define BBLOCKS4 "FL,FR,fp,fm,chip,chim"
    #define BBLOCKS5 "fp,fm"
    #define BBLOCKS6 "fp,fm"
    #redefine BBLOCKMAXRANK "6"
    #ifdef `NF'
        #if `NF'==4
            #redefine BBLOCKS0 "`BBLOCKS0',chitil,chitildag"
        #elseif `NF'==3
            #redefine BBLOCKS0 "`BBLOCKS1',chi,chidag,chitil,chitildag"
        #elseif `NF'==2
            #redefine BBLOCKS2 "`BBLOCKS2',chi,chidag,chitil,chitildag"
        #endif
    #endif
#endif
#define BBLOCKS "`BBLOCKS0'"
#do RANK=1,`BBLOCKMAXRANK'
    #redefine BBLOCKS "`BBLOCKS',`BBLOCKS`RANK''"
#enddo
* Building blocks plus building block-like things; basically anything that can come out of the Lagrangian
#define XBBLOCKS "Phi,gL,gR,h,gLdag,gRdag,hdag,`BBLOCKS'"
#ifdef `HASVECTOR'
    #ifdef `QED'
        #ifdef `HASVECTOR'
            #if `NA'
                #message[lagrexpand]~~~ QCD+QED does not support axial vector fields
                #terminate
            #endif
        #endif
        #ifdef `HASSCALAR'
            #message[lagrexpand]~~~ QCD+QED does not support (pseudo)scalar fields
            #terminate
        #endif
        #redefine XBBLOCKS "`XBBLOCKS',V,Q,l,r"
        cfunction A;
    #else
        #redefine XBBLOCKS "`XBBLOCKS',V,A,l,r"
    #endif
#endif
#ifdef `HASSCALAR'
    #redefine XBBLOCKS "`XBBLOCKS',S,P"
#endif

* Trace manipulation
#procedure trace()
    repeat;
        id trL(?x) * bb?{`XBBLOCKS'}(?lz) = trL(?x, bb(?lz));
*         This accounts for nested traces due to PAR=GEN/SQRT
        id trL(?x) * tr(?y) = tr(?y) * trL(?x);
    endrepeat;
    id trL(?x) * trR = tr(?x);
    id tr() = `NF';
#endprocedure
#procedure untrace()
    id tr(?x) = trL(?x) * trR;
    repeat id trL(?x, bb?{`XBBLOCKS'}(?lz)) = trL(?x) * bb(?lz);
#endprocedure
#procedure hidetrace()
*     Assumes the state produced by untrace()
    id bb?{`XBBLOCKS'}(?x) * trR = bb(?x, trR);
    id trL = 1;
#endprocedure
#procedure unhidetrace()
    multiply left trL;
    multiply right trL;
    id bb?{`XBBLOCKS'}(?x, trR) = bb(?x) * trR * trL;
    id trL*trL = 1;
*     Leaves the state accepted by trace()
#endprocedure

* Standard list of Lorentz indices
#define INDEXLISTNOMU "nu,ro,si,ka,la,al,be,ga,de"
#define INDEXLIST "mu,`INDEXLISTNOMU'"
#do MU={`INDEXLIST'}
    index `MU';
    symbol e`MU';* used for parity checking
#enddo



#if ((isdefined(HASSCALAR))||(isdefined(PQEMASS))||(isdefined(FULLMASS)))==0
    #define CHIISSCALAR
#endif

* Substitution of pre-expanded building blocks,
* with on-the-fly generation unless NOMAKE is defined,
* after applying transformations if TRANSFORM is defined
* without actually performing the substitution if DRYRUN is defined
#procedure substitute(BBLOCK,RANK)

*   Generate appropriate list of Lorentz indices according to rank
    #define INDICES ""
    #define R "`RANK'"
    #do INDEX={`INDEXLIST'}
        #if (`R'<=0)
            #breakdo
        #endif
        #redefine INDICES "`INDICES',`INDEX'?"
        #redefine R "{`R'-1}"
    #enddo

*     Apply transformation to objects with well-defined transformation properties before substituting them
*     The l,r on u(dag) is to indicate which equivalent transformation property to use
    #ifdef `TRANSFORM'
        #if `TRANSFORM'==CHIRAL
            id u(`FIELDSQ',r) = gR * u(`FIELDSV') * hdag;
            id u(`FIELDSQ',l) = h * u(`FIELDSV') * gLdag;
            id udag(`FIELDSQ',r) = h * udag(`FIELDSV') * gRdag;
            id udag(`FIELDSQ',l) = gL * udag(`FIELDSV') * hdag;

            id chi(`FIELDSQ') = gR * chi(`FIELDSV') * gLdag;
            id chidag(`FIELDSQ') = gL * chidag(`FIELDSV') * gRdag;

            id l(`FIELDSQ',mu?) = gL * l(`FIELDSV',mu) * gLdag - i_ * gL(mu) * gLdag;
            id r(`FIELDSQ',mu?) = gR * r(`FIELDSV',mu) * gRdag - i_ * gR(mu) * gRdag;
        #elseif `TRANSFORM'==P
            id u(`FIELDSQ',r?{r,l}) = udag(`FIELDSV');
            al udag(`FIELDSQ',r?{r,l}) = u(`FIELDSV');

            id chi(`FIELDSQ') = chidag(`FIELDSV');
            al chidag(`FIELDSQ') = chi(`FIELDSV');

            id l(`FIELDSQ',mu?) = r(`FIELDSV',mu);
            al r(`FIELDSQ',mu?) = l(`FIELDSV',mu);
        #elseif `TRANSFORM'==C
            id bb?{u,udag}(`FIELDSQ',r?{r,l}) = bb(`FIELDSV');

*             chi(dag) unchanged

            id l(`FIELDSQ',mu?) = -r(`FIELDSV',mu);
            al r(`FIELDSQ',mu?) = -l(`FIELDSV',mu);
        #endif
    #else
*         This is just stripping away transformation information
        id bb?{u,udag}(`FIELDSQ',r?{r,l}) = bb(`FIELDSV');
    #endif

*     Enact substitution, assuming first arguments are the desired powers of the fields
*     First deal with some primitives (heavily version-dependent!)
*     Current implementation is for the simple mesonic + QED ChPT.
    #if ((`BBLOCK'==chi)||(`BBLOCK'==chidag))
        #ifndef `DRYRUN'
            #ifdef `HASSCALAR'
                id chi(`FIELDSQ',?derivs)
                    =      2*B*S(?derivs) * `DELTA(0,0,0,1,0)'
                    + i_ * 2*B*P(?derivs) * `DELTA(0,0,0,0,1)';
                id chidag(`FIELDSQ',?derivs)
                    =      2*B*S(?derivs) * `DELTA(0,0,0,1,0)'
                    - i_ * 2*B*P(?derivs) * `DELTA(0,0,0,0,1)';
            #else
*                chi is a constant
                id bb?{chi,chidag}(`FIELDSQ',?derivs) = chi * `DELTA(0,0,0,0,0)' * delta_(nargs_(?derivs),0);
            #endif
        #endif
    #elseif (`BBLOCK'==lr)&&(`RANK'==1)
        #ifndef `DRYRUN'
            #ifdef `HASVECTOR'
                id l(`FIELDSQ',mu?)
                    = V(mu) * `DELTA(0,1,0,0,0)'
                    - A(mu) * `DELTA(0,0,1,0,0)';
                id r(`FIELDSQ',mu?)
                    = V(mu) * `DELTA(0,1,0,0,0)'
                    + A(mu) * `DELTA(0,0,1,0,0)';
            #endif
        #endif
    #else
        #define LOOPBODY "
            #include- names.hf
            #if isdefined(NOMAKE)==0
                #system `~MAKECMD' BBLOCK=`~BBLOCK' RANK=`~RANK' `~BBLOCKFILE'
            #endif
            #if isdefined(DRYRUN)
                #message[substitute]~~~ DRYRUN: not importing `~BBLOCK'(`~FIELDS'`~INDICES')
            #else
                #message[substitute]~~~ substituting `~BBLOCK'(`~FIELDS'`~INDICES')
                id `~BBLOCK'(`~FIELDS'`~INDICES') =
                    #include- `~BBLOCKFILE'
                    ;
            #endif"
        #call fieldloop()
    #endif
#endprocedured

cfunction trPhi;
functions tr,trL,trR, dL,dR;
functions bb, l,r, `XBBLOCKS';
functions h,gL,gR, hdag,gLdag,gRdag;
function ipart;
symbols `FIELDSV';
